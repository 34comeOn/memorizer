const dataBase = [
    {
        id: '63d264b1f97d7d9b9b3abbde',
        filter: '',
        repeatedTimeStamp: 1673874264971,  
        timesBeenRepeated: 3,      
        title: 'Что такое this?',
        answer: `this - контекст вызова- это значение специального объекта Зис.
        данное значение в контексте функций определяется вызывающей строной (caller"ом)
        по форме вызова.
        Если слева от скобок вызова (...) находится выражение типа reference type, то значит Зис 
        будет являться БАЗОВЫЙ ОБЪЕКТ этого значения (base).
        Для работы вызовов типа user.hi(), JavaScript использует трюк – точка '.' возвращает не саму функцию, а специальное значение «ссылочного типа», называемого Reference Type.
        Этот ссылочный тип (Reference Type) является внутренним типом. Мы не можем явно использовать его, но он используется внутри языка.

        Значение ссылочного типа – это «триплет»: комбинация из трёх значений (base, name, strict), где:

        base – это объект.
        name – это имя свойства объекта.
        strict – это режим исполнения. Является true, если действует строгий режим (use strict).
        Результатом доступа к свойству user.hi является не функция, а значение ссылочного типа. Для user.hi в строгом режиме оно будет таким:
        (user, "hi", true)
        Когда скобки () применяются к значению ссылочного типа (происходит вызов), то они получают полную информацию об объекте и его методе, и могут поставить правильный this (user в данном случае, по base).
        Таким образом, значение this передаётся правильно, только если функция вызывается напрямую с использованием синтаксиса точки obj.method() или квадратных скобок obj['method']().

        Во всех остальных случаях (другое значение отличное от reference), значением Зис всегда является null, что в последствии меняется на window
        или undefined.
        У стрелочных функций НЕТ this. Значение Зис берется снаружи. Также поэтому методы call, apply, bind не могут привязать контекст у стрелочной
        функции.
        Поскольку у стрелок нет this и super они "прозрачно" встраиваются во внешний контекст объектов instance"ов класса.`,
    },    
    {
        id: '63d27842f97d7d9b9b3abbe0',
        repeatedTimeStamp: 1674024695949,  
        timesBeenRepeated: 3,      
        title: 'Что такое Замыкание?',
        answer: `Замыкание - это комбинация функции и лексического окружения, в котором эта функция
        была определена. В момент декларации функции в ее скрытое свойство [Environment] автоматически записывается ссылка на лексическое
        окружение того места, где она была декларирована.
        Лексическое окружение- это внутренний (скрытый) объект выполняемого скрипта, блока кода, функции. 
        Он состоит из двух частей:
        1) Объект Environment Record, в котором КАК СВОЙ]сТВА хранятся все локальные переменные, значение this.
        2) ССылка на внешнее лексическое окружение (которое соответствует коду снаружи от текущих фигурных скобок).`,
    },    
    {
        id: 3,
        filter: 'list--filter__react',
        repeatedTimeStamp: 1673877867177,  
        timesBeenRepeated: 2,      
        title: 'Что такое React?',
        answer: 'React - это JS библиотека с открытым исходным кодом, разработанная компанией Фейсбук. Предназначена для создания пользовательских интерфейсов. Реакт отвечает за слой Представления в мобильных и веб приложениях. Основная философия - компонентный подход. То есть весь интерфейс может быть разбит на минимальные функционирующие единицы - Компоненты. Переиспользуя такие единицы в других местах приложения, можно ускорить разработку. Особенности использования: 1) Использование Virtual ДОМ вместо реальногг, поскольку операции с реальным ДОМ ресурсозатратны. Виртуальный ДОМ- это по сути объект, на основани которого строится реальный ДОМ. Операции перерисовки происходят намного быстрее. 2) Поддержка рендеринга на стороне сервера "SSR server side rendering". Проблема - вся разметка отрисовывается внутри одного корневого элемента. Что плохо для SEO (Search Engine Optimization). С SSR первоначальная разметка строится на сервере, полностью передается и отрисовывается на клиенте. 3) Реакт придерживается принципа однонаправленного потока данных. Все данные передаются от корневых компонентов во вложенные но не в обратном направлении. 4) Использование переиспользуемых компонентов для построения пользовательского интерфейса.',
    },    
    {
        id: 4,
        filter: '',
        repeatedTimeStamp: 1673878420687,  
        timesBeenRepeated: 2,      
        title: 'Что такое HTML?',
        answer: 'HTML - это hypertext markup language. Язык разметки гипертекста.',
    },    
    {
        id: 5,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Что такое http/https?',
        answer: 'http - HyperText Transfer Protocol. Это клиент-серверный протокол. Протокол для передачи гипертекстовых документов по типу HTML. Используется для передачи произвольных данных. Состоит из стартовой строки (URL), заголовка и тела сообщения. Стартовая строка ответа - это трехзначный код. Протокол http передает данные в обычном виде, злоумышленниук может их перехватить. http S- secure шифрует все данные и делает невозможным их чтение при перехвате. Шифрование обеспечивают механизмы SSL и TSL',
    },    
    {
        id: 6,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 2,      
        title: 'Что такое URI и URL и URN',
        answer: `
        URI — символьная строка, позволяющая идентифицировать какой-либо ресурс: документ, изображение, файл, службу, ящик электронной 
        почты и т. д. Прежде всего, речь идёт о ресурсах сети Интернет и Всемирной паутины. URI предоставляет простой и расширяемый 
        способ идентификации ресурсов. Расширяемость URI означает, что уже существуют несколько схем идентификации внутри URI, и ещё
        больше будет создано в будущем.
        URI является либо URL, либо URN, либо одновременно обоими.
        URL — это URI, который, помимо идентификации ресурса, предоставляет ещё и информацию о местонахождении этого ресурса. А URN — это 
        URI, который только идентифицирует ресурс в определённом пространстве имён (и, соответственно, в определённом контексте), но не 
        указывает его местонахождение. 
        URL - Uniform resource locator. Это унифицированный указатель ресурса
        `,
    },    
    {
        id: 7,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Коды ответа сервера',
        answer: `1xx - Информирование о процессе передачи запроса.
                 2xx - Информирование об успешной передаче запроса.
                 3xx - Информирование о перенаправлении.
                 4xx - Ошибки клиента означают, что либо ты ищешь то чего нет, либо не правильно ищешь, либо тебе сюда нельзя. 
                 5xx - Ошибки сообщающие о проблемах на сервере.
                `,
    },    
    {
        id: 8,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Что такое заголовки и тело запроса',
        answer: 'Заголовки - это параметры, которые определяю запрос или описывают тело сообщения. Информация о браузере, языке, авторизации и тд. Тело запроса - это данные, которые мы передаем в запросе (например текст комментария), либо ответ. который мы получаем оот сервера',
    },  
    {
        id: 9,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Что такое SSL?',
        answer: 'SSL - это secure sockets layer работает, когда мы подключаемся к сайту, то просим, чтобы сайт сначала идентифицировал себя. В ответ он пришлет нам копию своего SSL сертификата. Браузер проверит его и если ок, то начнется обмен шифрованными данными ',
    },  
    {
        id: 10,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Что такое TLS?',
        answer: `TLS - это Transport Layout Security- прокаченная версия SSL`,
    },   
    {
        id: 11,
        filter: 'list--filter__network',
        repeatedTimeStamp: 
        1673874264971,  
        timesBeenRepeated: 4,      
        title: 'Что такое JSON?',
        answer: `JavaScript Object Notation. это общий формат обмены данными. Формат ключ- значение.                                                                                                                                                                .Метод JSON.stringify() берёт объект и преобразует его в строку.
        объект в формате JSON имеет несколько важных отличий от объектного литерала:
        
        Строки используют двойные кавычки.
        Имена свойств объекта также заключаются в двойные кавычки. 
        JSON.stringify может быть применён и к примитивам.
        JSON поддерживает следующие типы данных:
        
        Объекты { ... }
        Массивы [ ... ]
        строки,
        числа,
        логические значения true/false,
        null.
        
        JSON.stringify пропускает:
        Свойства-функции (методы).
        Символьные ключи и значения Symbol.
        Свойства, содержащие undefined.
        с BigInt воде будет ошибка
        `,
    },   
    {
        id: 12,
        filter: 'list--filter__react',
        repeatedTimeStamp: 1674026959852,  
        timesBeenRepeated: 1,      
        title: 'JSX',
        answer: `JSX- это расширение синтаксиса JavaScript. JSX создаёт «элементы» React. 
        Можно сказать, что это синтаксический сахар. Под капотом функция React.creteElement()
        `,
    },   
    {
        id: 13,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Что такое XML?',
        answer: `Это язык разметки в котором можно задавать синтаксис, структуру, тип данных и их модель. Даные обарачиваются в разметку.
        `,
    },   
    {
        id: 14,
        filter: 'list--filter__react',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'virtual DOM',
        answer: `DOM не был расчитан для создания динамического пользовательского интерфейса. 
        Поиск элемента или его динамическая вставка занимают длительный временной интервал.
        Если на странице много динамической логики, по perfomance будет проседать.
        Для решения проблемы Реакт предложил Виртуальный ДОМ - легковесный объект, который является
        копией реального ДОМ. Поэтому если в компоненте происходят какие-то изменения, которые ведут к перерисовке,
        То сначала происходит сравнение старой версии Виртуал ДОМ и новой. После нахождения разницы изменения
        применяются к реальному ДОМ дереву. Этот процесс называется СОГЛАСОВАНИЕ. В результате перерисовывается не вся 
        страница, а лишь часть изменений.
        `,
    },
    {
        id: 15,
        filter: 'list--filter__oop',
        repeatedTimeStamp: 1674026959852,  
        timesBeenRepeated: 1,      
        title: 'Что такое Class?',
        answer: `Class- это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения
        (свойства) и реализацию поведения (методы)ю
        Класс - это разновидность функции. ОТЛИЧИЯ от функций: 
        1) Конструктор класса не может быть вызван без NEW.
        2) Методы класса являются неперечисляемыми. Если пройтись по объекту циклом for...in, 
        от мы не получим методы класса.
        3) Классы всегда используют "use strict".

        В статических методах static классов НЕЛЬЗЯ использовать this. Эти методы принадлежат только классу
        и не передаются экземплярам. Соответственно получим ошибку.
        Стрелочные функции, которые создаются ВНУТРИ класса, ссылаютсяна экземпляр (объект) этого класса
        (то есть this для них - это объект, который является экземпляром класса)
        `,
    },  
    {
        id: 16,
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Типы данных в JS?',
        answer: `Ecma script выделяет 8 типов даных из которых 6 типов: bigInt, Symbol, undefined, string,
        boolean, number являются примитивами. Седьмой тип данных null специально относят к примитивам, 
        поскольку по поведению он и правда примитив, но приэтом от Нал унаследованны все объекты. По
        этой причине его тип это объект.
        Примитивные типы данных копируются по значению.
        Они являются иммутабельными, те не могут быть модифицированы, а только быть перезаписаны новым полным значением.
        Восьмой тип данных - это обджект. Является простой структурой данных, которая используется не только для хранения,
        но и для создания других структур данных.
        Объект копируется и хранится по ссылке.
        Переменная хранит не сам объект, а его адрес в памяти, то есть ссылку на него. 
        `,
    },  
    {
        id: 17,
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Что такое DOM?',
        answer: `ДОМ - (Document Object Model) это модель представляющая из себя изначальный видHTML страницы.
        Это представление HTML документа в виде дерева тэгов.
        Каждый узел этого дерева - это объект. Тэги являются узлами-элементами.
        html- окрневой узел. Текст внутри элементов образует текстовые узлы.
        4 основных видов узлов (всего вроде 10): 1) document- входная точка в DOM. 
        2) Узлы- элементы HTML теги- основные строительные блоки.
        3) Текстовые узлы
        4) Комментарии
        `,
    }, 
    {
        id: 18,
        filter: 'list--filter__typeScript',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Что такое TypeScript?',
        answer: `TypeScript - это надмножество язака (расширенная версия) JS с возможностью явного статического
        назначения типов, поддержку классов и интерфейсов. Можно сказать, что это язык, а также набор инструментов.
        Преимущество ТС перед ДЖАВАС - возможность создания в различных текстовых редакторах такое среды разработки, 
        которая позволяет прямо в процессе ввода кода выявлять распространенные ошибки. В больших проектах ведет
        к повышению надежности программ, которые при этом можно разварачивать в тех же средах, где и работают обычные 
        JS приложения. Интегрировать TS в приложение также можно постепенно. Достаточно небольших настроек для linter"а
        и сборщика, после чего поменять расширение файлов с JS JSX HA TS TSX  
        `,
    }, 
    {
        id: 19,
        filter: 'list--filter__typeScript',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Основные компоненты TypeScript?',
        answer: `Три основных компонента:
        1) Язык - специфичный синтаксис, ключевые слова.
        2) Сборщик, компилятор - он с открытым исх кодом, кроссплатформенный, открытая спецификация, написан на TS.
        Он выполняет преобразования ТайпСкр кода в ДжавСкрип код. И выдает сообщения об ошибках.
        Позволяет объединить несколько Тайпскр файлов в один выходной ТайпСкр файл. 
        Создает карты кода (Sourse map)
        3) вспомогательные инструменты. Предназначены для облегчения процесса разработки с его использованием в различных
        редакторах кода   
        `,
    }, 
    {
        id: 20,
        filter: 'list--filter__typeScript',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Особенности TypeScript?',
        answer: `1) Кроссплатформенность - в любой операционной системе мб устан.  
        2) Объектно ориентированный язык- предоставляет такую функциональность, как клаасы,
        интерфейсы и модули
        3) Статическая проверка типов. ТС использует статическую типизацию и помогает проверять типы
        во время компиляции. Таким образом мождно найти ошибки при написании кода, без запуска скрипта.
        4) Взаимодействие с DOM - можно добавлять и убирать элементы
        5) ES6 синтаксис (класс, интерфейс, стрелочные функции и тд)
        `,
    }, 
    {
        id: 21,
        filter: 'list--filter__typeScript',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Система типов в TypeScript?',
        answer: `Система типов представляет различные типы значений, поддерживаемых языком. 
        ТС проверяет достоверность передаваемых значений до того как они будут сохранены или обработаны
        программой. Типы делятся на две большие категории:
        1) ВСТРОЕННЫЕ - число, строка, булевое значение, void, null, undefined
        2) ОПРЕДЕЛЯЕМЫЕ ПОЛЬЗОВАТЕЛЕМ - enums (перечисления),  классы, массивы, интерфейсы и кортэжи (tuple)
        это массив, каждый элемент которого имеет свой жестко заданный тип
        `,
    }, 
    {
        id: 22,
        filter: 'list--filter__typeScript',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Разница между типом и интерфейсом?',
        answer: `1) Типы могут объединяться с другим типом, интерфейс - нет
        2) Тип не может дополняться (), интерфейс - может
        3)Классы могут расширять интерфейсы, типы- нет.
        4) Тип расширяется в сообщениях об ошибках и логах
        `,
    }, 
    {
        id: 23,
        filter: 'list--filter__typeScript',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Дженерики?',
        answer: `Помогают писать универсальный, переиспользуемый код. Мы как бы задаем переменную вместо
        конкретного типа  function include<T> (array: T[], query% T):boolean { return false}
        `,
    }, 
    {
        id: 24,
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Redux, ключевые принципы?',
        answer: `Redux- это стабильный предсказуемый контейнер для хранения состояния JS приложений основанный на 
        паттерне проектирования FLUX. Предназначен для управления состоянием приложения и базируется на трех 
        фундаментальных принципах:
        1) Единственный источник истины
        2) Состояние доступно только для чтения
        3) Изменение производится при помощи только чистых функций

        Для определения того, как изменяется состояние создаются reduser"ы.
        Reduser - Это чистая функция, принимающая предыдущее состояние в качестве аргумента и возвращающее новое
        состояние
        `,
    }, 
    {
        id: 25,
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Что такое Flux?',
        answer: `Flux - архитектурный подход или набор шаблонов программирования для построения пользовательского
        интерфейса веб приложений, построенный на однонаправленных потоках данных.
        Слои:
        1) Action - по сути просто события. Поступают действия ассинхронно, но деспетчиризация является 
        синхронным процессом. Кроме имени действия могут иметь полезную нагрузку (payLoad). Она содержит относящиеся 
        к действию данные.
        2) Dispatcher - диспетчер. Предназначен для передачи действий хранилищу Store. В нем одни хранилища регистрируют
        свои коллБеки и зависимости между другими хранилищами.
        3) store - хранилище - место, где сосредоточен State состояние приложения. Изменение состояния хранилища 
        происходит строго на основанииданных в Action и старого состояния хранилища при помощи чистых функций.
        4) View - представление - это компонент, который обычно отвечает за выдачу информации пользователю
        `,
    }, 
    {
        id: 26,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Что такое межсайтовый скриптинг или XSS?',
        answer: `XSS - это распространенная уязвимость. Суть - злоумышленнику удается внедрить на страницу
        JS код, который не был предусмотрен разработчиками. Этот код будет выполняться каждый раз, когда
        пользователи будут заходить на странцу приложения. Страница с сервера не изменяется. XSS атака 
        использует уязвимость на странице, которая включает переменную, отправленную в запрос для отображения
        в необработанном виде в ответе. Специфика в том, что вредоносный код может использовать авторизацию пользователя
        в веб системе для получения к ней расширенного доступа, или для получения авторизационных данных пользователя
        
        `,
    }, 
    {
        id: 27,
        repeatedTimeStamp: 1674014610351,  
        timesBeenRepeated: 1,      
        title: 'Что такое REST?',
        answer: `ReST- REpresentational State Transfer - передача состояния представления это архитектурный стиль
        взаимодействия компонентов распределенного приложения в сети. Представляет собой согласованный набор 
        ограничений учитываемых при проектировании распределенной ГиперМедиа системы. В определенных случаях, 
        например интернетмагазины, поисковые системы, прочие системы основанные на данных, это приводит к 
        повышению производительности и упрощению архитектуры.
        REST - простой интерфейс управления информацией без дополнительных внутренних прослоек.
        Каждая единица информации определяется глобальным идентификатором таким как URL.
        А каждый URL имеет строго заданный формат.
        Принципы:
        1) Клиент и сервер две разные сущности. Сервер хранит информацию, клиент ей пользуется. 
        2) Сервер не хранит состояние клиента. Вся информация должна передаваться через запросы. 
        3) Кэшируемость настраивается через заголовки. Информация может быть закэширована на стороне сервера и 
        на стороне клиента. Можно закэшировать MySQL запросы и выдавать готовые страницы, не обращаясь к базе. 
        4) Единство интерфейса - все должны общаться по одному протоколу (только http). 
        5) Многоуровневость. Сервисы могут быть разбиты на много модулей уровней, они должны друг с другом общаться 
        по цепочке. Каждый уровень системы общается только со смежными уровнями. 
        6) Предоставление кода по запросу (клиент отправил запрос и получил что-то). 
        7) Единая точка входа на сервер. Используем Эндпоинты
        `,
    }, 
    {
        id: 28,
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Что такое GraphQL?',
        answer: `GraphQL- это библиотека или язык запросов. By Facebook. Ее задача снизить нагрузку на сервера.
        Если данные получаемые через запросы РЕСТ АПИ нужны не вполном объеме, то нужна архитектура микросервисов.
        Граф позволяет полностью конфигурировать на клиенте данные, которые мы хотим получить.
        Снижает нагрузку на сервера и количество данных, которые получает пользователь. 
        `,
    }, 
    {
        id: 29,
        repeatedTimeStamp: 1674040003853,  
        timesBeenRepeated: 2,      
        title: 'EventLoop',
        answer: `EventLoop - бесконечный чикл, в котором движок JS ожидает задачи, исполняет их и снова ожидает
        появления новых.
        Если поступает задача, когда движок занят чем-то другим, то она становится в очередь  Makrotask queue, 
        например: (mousemove, click)- события, setTimeout - истечение таймера.
        Задачи из очереди исполняются по правилу FIFO.
        1) Рендеринг не происходит во время выполнения задачи.
        2) Если задача выполняется слишком долго, и браузер не может обрабатывать пользовательские действия, 
        браузер предлагает "убить" такую задачу.
        Алгоритм работы Event loop (упрощенный):
        1) Выбрать и исполнить старейшую задачу из очереди макрозадач (например "script");
        2) Исполнить все микрозадачи: - пока очередь микрозадач не пуста - выбрать из очереди старейшую микрозадачу
        и исполнить ее.
        3) Отрисовать изменения страницы, если они есть.
        4) Если очередь макрозадач пуста - подождать, пока появится макрозадача.
        
        Чтобы добавить в очередь новую макрозадачу: Используем setTimeout(f) с нулевой задержкой. 
        Это можно использовать для разбиения больших вычислений на части, чтобы браузер мог реагировать на пользовательские 
        события (и для отложенного выполнения действия).
        
        Для добавления в очередь новой микрозадачи:
         - Используем queueMikrotask(f)
         - Также обработчики промисов then/catch/finally  выполняются в рамках очереди микрозадач. Микрозадачи
         также используются под капотом await так как это форма обработки промиса.
        `,
    }, 
    {
        id: 30,
        filter: 'list--filter__oop',
        repeatedTimeStamp: 1674024695949,  
        timesBeenRepeated: 1,      
        title: 'SOLID',
        answer: `S- substitution princeple. Принцип единой ответственности. Каждая сущность должна выполнять единую функцию.
        О- open-closed . Принцип открытости-закрытости. Сущности должны быть открыты для дополнения, но закрыты для изменений.
        L - Принцип подстановки Барбары Лисков.  Классы наследники не могут противоречить родительскому классу. Не могут предоставлять 
        интерфейс уже базового.
        I - interface segregation. Принцип разделения интерфейсов. Интервейсы не должны быть избыточными. Удобнее использовать
        более тонкие интерфейсы.
        D - dependency iversion. принцип инверсии зависимостей. Модули верхнего уровня не должны зависеть от модуля нижнего
        уровня, классы не должны зависеть от деталей, это детали должны зависеть от абстракций. Детали должны зависеть от
        абстракций.
        `,
    }, 
    {
        id: 31,
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'GIT',
        answer: `Git reset soft, reset hard разница?
        git reset hard позволяет полностью удалить коммит
        git reset mixed (по умолнчаению) изменения попадают в Индексе, гит за ними следит
        git reset soft изменения есть, но Гит за ними не следить (состояние до git add .)
        Разница rebase и merge?
        Команда merge - это слияние веток, создается коммит слияния. Может засорять историю коммитов. Мердж позволяет править конфликты.
        git rebase - перемещает одну ветку поверх другой без коммита.
        Sqoush commit? - когда мы хотим сделать интерактивный ребейз и подредактировать историю коммитов. Изменения попадут в предыдущий 
        коммит, а этого коммита не будет.

        `,
    }, 
    {
        id: 32,
        filter: 'list--filter__oop',
        repeatedTimeStamp: 1674026959852,  
        timesBeenRepeated: 1,      
        title: 'ООП',
        answer: `Объектно-ориентированное программирование — это методология программирования, в которой все важные вещи представлены 
        объектами, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.
        родительский класс принято называть суперклассом, а его потомков — подклассами. Подклассы наследуют свойства и поведения
        своего родителя, поэтому в них содержится лишь то, чего нет в суперклассе. Например, только коты могут мурчать, а собаки — лаять.
        Когда вы заводите автомобиль, вам достаточно повернуть ключи зажигания или нажать кнопку. Вам не нужно вручную соединять провода 
        под капотом, поворачивать коленчатый вал и поршни, запуская такт двигателя. Все эти детали скрыты под капотом автомобиля. 
        Вам доступен только простой интерфейс: ключ зажигания, руль и педали. Таким образом, мы приходим к определению интерфейса — 
        публичной ( public ) части объекта, доступной остальным объектам.
        `,
    }, 
    {
        id: 33,
        filter: 'list--filter__oop',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Абстракция ООП',
        answer: `
        Абстракция — это модель некоего объекта или явления реального мира, в которой опущены незначительные детали, не играющие 
        существенной роли в данном контексте. Так, например, класс Самолёт будет актуален как для программы тренажёра пилотов, так и 
        для программы бронирования авиабилетов, но в первом случае будут важны детали пилотирования самолёта, а во втором — лишь 
        расположение и занятость мест внутри самолёта.
        `,
    }, 
    {
        id: 34,
        filter: 'list--filter__oop',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Инкапсуляция ООП',
        answer: `
        Инкапсуляция — это способность объектов скрывать часть своего состояния и поведения от других объектов, предоставляя 
        внешнему миру только определённый интерфейс взаимодействия с собой. Например, вы можете инкапсулировать что-то внутри 
        класса, сделав его приватным ( private ) и скрыв доступ к этому полю или методу для объектов других классов. Чуть 
        более свободный, защищённый ( protected ) режим видимости сделает это поле или метод доступным в подклассах.
        `,
    }, 
    {
        id: 35,
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Интерфейс',
        answer: `
        В объектных языках программирования, с помощью механизма интерфейсов, которые обычно объявляют через ключевое слово 
        interface , можно явно описывать «контракты» взаимодействия объектов. Например, вы создали интерфейс ЛетающийТранспорт 
        с методом лететь (откуда, куда, пассажиры) , а затем описали методы класса Аэропорт так, чтобы они принимали любые 
        объекты с этим интерфейсом. Теперь вы можете быть уверены, что любой объект, реализующий интерфейс — будь то Самолёт , 
        Вертолёт или ДрессированныйГрифон — сможет работать с Аэропортом .
        Вы можете как угодно менять код классов, реализующих интерфейс, не беспокоясь о том, что Аэропорт перестанет быть 
        с ними совместимым.
        `,
    }, 
    {
        id: 36,
        filter: 'list--filter__oop',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Наследование ООП',
        answer: `
        Наследование — это возможность создания новых классов на основе существующих. Главная польза от наследования — повторное 
        использование существующего кода. Расплата за наследование проявляется в том, что подклассы всегда следуют интерфейсу
         родительского класса. Вы не можете исключить из подкласса метод, объявленный в его родителе.
        `,
    }, 
    {
        id: 37,
        filter: 'list--filter__oop',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Полиморфизм ООП',
        answer: `
        Полиморфизм — это способность программы выбирать различные реализации при вызове операций с одним и тем же названием.
        Для лучшего понимания полиморфизм можно рассматривать как способность объектов «притворяться» чем-то другим. В приведённом 
        выше примере собаки и коты притворялись абстрактными животными.
        `,
    }, 
    {
        id: 38,
        filter: 'list--filter__oop',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Отношения между объектами ООП',
        answer: `
        • Зависимость: Класс А могут затронуть изменения в классе B.
        • Ассоциация: Объект А знает об объекте B. Класс А зависит от B.
        • Агрегация: Объект А знает об объекте B и состоит из него. Класс А зависит от B.
        • Композиция: Объект А знает об объекте B, состоит из него и управляет его жизненным циклом. Класс А зависит от B.
        • Реализация: Класс А определяет методы объявленные интерфейсом B. Объекты А можно рассматривать через интерфейс B. Класс А зависит от B.
        • Наследование: Класс А наследует интерфейс и реализацию класса B, но может переопределить её. Объекты А можно рассматривать 
          через интерфейс класса B. Класс А зависит от B.
        `,
    }, 
    {
        id: 39,
        filter: 'list--filter__patterns',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 2,      
        title: 'Паттерны',
        answer: `
        Паттерн проектирования — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.
        — это высокоуровневое описание решения, реализа- ция которого может отличаться в двух разных программах.
        Если привести аналогии, то алгоритм — это кулинарный рецепт с чёткими шагами, а паттерн — инженерный чертёж, на котором 
        нарисовано решение, но не конкретные шаги его реализации.
        состоят из таких пунктов:
        • проблема, которую решает паттерн;
        • мотивации к решению проблемы способом, который пред- лагает паттерн;
        • структуры классов, составляющих решение;
        • примера на одном из языков программирования;
        • особенностей реализации в различных контекстах;
        • связей с другими паттернами.
        `,
    }, 
    {
        id: 40,
        filter: 'list--filter__patterns',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Паттерны. Классификация.зачем знать паттерны?',
        answer: `
        • Порождающие паттерны беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.
        • Структурные паттерны показывают различные способы построения связей между объектами.
        • Поведенческие паттерны заботятся об эффективной коммуникации между объектами.
        Зачем? 
        Проверенные решения. Вы тратите меньше времени, используя готовые решения, вместо повторного изобретения велосипеда. 
        Стандартизация кода. Вы делаете меньше просчётов при проектировании, используя типовые унифицированные решения, 
        так как все скрытые проблемы в них уже давно найдены.
        Общий программистский словарь. Вы произносите название паттерна, вместо того, чтобы час объяснять другим программистам, 
        какой крутой дизайн вы придумали и какие классы для этого нужны.
        `,
    }, 
    {
        id: 41,
        filter: 'list--filter__react',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Методы жизненного цикла компонента React',
        answer: `
        1) constructor - это конструктор компонента, который вызывается ДО того, как компонент будет смонтирован.
        2) componentDidMount - вызывается сразу после монтирования компонента. Отличное место, для создания сетевых запросов
        и настройки подписок компонента на различные события. Также в этом методе должны происходить действия для 
        работы которых требуется наличие ДОМ узлов (useLayoutEffect).
        3) componentDidUpdate - вызывается сразу после обновления. Метод позволяет работать с ДОМ при обновлении
        компонента. Подходит для таких сетевых запросов, которые выполняются на результате сравнения текущих Пропсов
        с предыдущими.
        4) componentWillUnmount - вызывается непосредственно перед размонтированием компонента. В нем выполняются необходимые
        сбросы таймера, а также сетевых запросов, подписок, созданых в componentDidMount.
        5) shouldComponentUpdate - вызывается перед рендером, получает новые пропсы и состояние. Используется для повышения
        производительности. Чтобы избежать лишних перерисовок.
        6) render - единственный обязательный метод в компоненте. Предназначен для возврата разметки.
        7) getDerivedStateFromProps - вызывается непосредственно перед методом render. Возвращает объект для изменения
        состояния или null, чтобы ничего не обновлять. Метод существует для редких случаев, когда состояние зависит от
        изменения в пропсах.
        8) getSnapshotBeforeUpdate - позволяет компоненту брать некоторую информацию из ДОМ перед ее возможным изменением
        9) getDerivedStateBeforeError - метод жизненного цикла вызывается после возникновения ошибки у компонента
        потомка. Он получает ошибку в качестве параметра и возвращает значение для обновления состояния.
        10) componentDidCatch - используется для логирования ошибок. Вызывается после возникновения ошибки у компонента 
        потомка
        `,
    }, 
    {
        id: 42,
        filter: 'list--filter__react',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Стадии жизненного цикла компонента React',
        answer: `
        Жизненный цикл компонента состоит из трех основных стадий: 
        1) Монтирование - компонент готов к встраиванию в браузерный ДОМ. Эта стадия охватывает инициализацию в 
        constructor, а также методы жизненного цикла getDerivedStateFromProps, render, componentDidMount.
        2) Updating - на данной стадии компонент обновляется или из-за получение новых Пропсов, либо из-за
        обновления состояения. Эта стадия охватывает такие методы жизненного цикла как: getDerivedStateFromProps
        shouldComponentUpdate, render, getSnapshopBeforeUpdate, componentDidUpdate.
        3) Размонтирование - на этой стадии компонент удаляется из браузерного ДОМ. Включает в себя метод 
        жизненного цикла componentWillUnmount. 
        В Реакт имеется особsе стадии (фазы) применения изменения к ДОМ.
        4) Rendering - компонент рендерится без каких либо побочных еффектов. На данной стадии Реакт может приостанавливать,
        прерывать и перезапускать рендеринг.
        5) PreCommit - перед обновлением компонента есть момент, когда Реакт читает ДОМ через getSnapshotBeforeUpdate.
        6) Commit - Реакт изменяет ДОМ и выполняет завершающие методы жизненного цикла такие как componentDidMount 
        при монтировании, componentDidUpdate при обновлении, componentWillUmount при размонтировании.
        `,
    }, 
    {
        id: 43,
        filter: 'list--filter__react',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Синтетические события React',
        answer: `
        Synthetic Event - это кроссбраузерная оболочка для нативных событий браузера. То есть любые события с которыми
        работает Реакт являются не нативными, а всего лишь обертками. Данный API полностью аналогичен браузерному 
        включая stopPropagation(), preventDefault(). Поэтому разницы особо и не заметно, однако синтетические события
        работают одинакого во всех браузерах. Поэтому не требуется никакие fallback'и или полифилы.
        `,
    }, 
    {
        id: 44,
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Что такое Промисы?',
        answer: `
        Промисы - это один из приемов работы с ассинхронным кодом в JS. Это объект, который может вернуть одно значение 
        в будущем. Либо выполненное значение, либо причину, по которой промис не был выполнен те ошибку. 
        Промис может находиться в одном из трех возможных состояний:
        1) Выполнено - fullfiled.
        2) Ожидает выполнения - pending.
        3) Отклонено - rejected.
        При использовании промисов можно добавлять колл-бек функции для обработки выполненного значения или для 
        обработки ошибки. Для такого взаимодействия используется чейнинг или цепочка вызывов с методами then/catch.
        `,
    }, 
    {
        id: 45,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Разница между PUT, PATCH и POST?',
        answer: `
        Метод запроса HTTP PATCH частично изменяет ресурс. Метод запроса HTTP PUT создаёт новый ресурс или заменяет 
        представление целевого ресурса, данными представленными в теле запроса.
        Разница между PUT и POST в том, что PUT является идемпотентным, т.е. единичный и множественные вызовы этого 
        метода, с идентичным набором данных, будут иметь тот же результат выполнения (без сторонних эффектов), в 
        случае с POST, множественный вызов с идентичным набором данных может повлечь за собой сторонние эффекты.
        `,
    }, 
    {
        id: 46,
        filter: 'list--filter__react',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Хуки useCallback(), useMemo()',
        answer: `
        1) Хук useCallback - может использоваться для оптимизации рендеринга функциональных компонентов. Он возвращает 
        мемоизированную версию коллбека. Это означает, что такой коллбек обновляется только при изменении его зависимостей.
        Это может быть полезным при передачи коллбеков оптимизированным дочерним компонентам.
        2) Хук useMemo - может использоваться для оптимизации вычислений производимых в функциональных компонентах.
        Похож на useCallback за исключением того, что он принимает любые значения, а не толоько функции. В основном 
        он принимает функцию, возвращающую значение и массив зависимостей. Значение, возвращаемое функцией, вычисляется 
        повторно только при изменении зависсимостей

        `,
    }, 
    {
        id: 47,
        filter: 'list--filter__react',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Хуки useImperativeHandle(), useLayoutEffect()',
        answer: `
        1) Хук useImperativeHandle - позволяет кастомизировать значение, передаваемое родительскому компоненту с помощью ref.

        2) Хук useLayoutEffect - он запускается после выполнения всех манипуляций с ДОМ, но до его отрисовки браузером. Это
        может быть полезным для получения дополнительной информации из ДОМ (получение величины прокрутки) и использования 
        этой информации для корректировки ДОМ или зауска повторного рендеринга путем обновления состояния.

        `,
    }, 
    {
        id: 48,
        filter: 'list--filter__react',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'useRef(), React.forwardRef()',
        answer: `
        Хук useRef() фактически заменяет метод getElementById(). Он дает нам доступ к ДОМ элементу в имеративном стиле.
        Дает нам ссылку на элемент.
        forwardRef нужен для того, чтобы передать ref в Реакт компонент, чтобы можно было передать ее ниже по цепочке
        в целевой элемент. Для этого оборачиваем компонент в "React.forwardRef(компонент, ref)" и вторым аргументом передаем
        ref.

        `,
    }, 
    {
        id: 49,
        filter: 'list--filter__react',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Хук useImperativeHandle',
        answer: `
        Хук useImperativeHandle() позволяет менять значение ref и вообще логику, внутри компонента который мы оборачиваем 
        forwardRef(component, ref). 
        Хороший пример, что есть кнопки, которые открывают модальное окно, закрываю его, да/ нет внутри окна.
        Они находятся на одном уровне, чтобы не мудрить с изменением состояния, можно компоненту модального окна передать
        Реф, который будет в нем производить разные действия при нажатии разных кнопок.
        `,
    }, 
    {
        id: 50,
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Что такое Webpack',
        answer: `
        это сборщик модулей JavaScript с открытым исходным кодом. Он создан в первую очередь для JavaScript, но может 
        преобразовывать внешние ресурсы, такие как HTML, CSS и изображения, если включены соответствующие загрузчики. 
        webpack принимает модули с зависимостями и генерирует статические ресурсы, представляющие эти модули.
        webpack также предоставляет встроенный сервер для разработки, называемый сервером для разработки webpack 
        (англ. webpack dev server), который можно использовать в качестве HTTP-сервера для обслуживания файлов во время 
        разработки. Он также предоставляет возможность использовать горячую замену модуля.
        `,
    }, 
    {
        id: 51,
        filter: 'list--filter__patterns',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Качества хорошей архитектуры.Базовые принципы проектирования',
        answer: `
        Повторное использование программной архитектуры и кода — это один из самых распространённых способов снижения 
        стоимости разработки.
        Расширяемость. Вы выпустили видеоигру под Windows, но затем понадоби- лась поддержка macOS.
        Вы придумали идеальную архитектуру интернет-магазина, но через месяц пришлось добавить интерфейс для заказов 
        по телефону.
        Вот почему даже мало-мальски опытный программист про- ектирует архитектуру и пишет код с учётом будущих изменений.
        Базовые принципы проектирования:
        1) Инкапсулируйте то, что меняется.
        2) Программируйте на уровне интерфейса. Программируйте на уровне интерфейса, а не на уровне реализации. Код 
        должен зависеть от абстрак- ций, а не конкретных классов.
        3) Предпочитайте композицию наследованию. 
        4) Принципы SOLID.
        `,
    }, 
    {
        id: 52,
        filter: 'list--filter__patterns',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Пораждающий паттерн Строитель',
        answer: `
        Строитель — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово.
        Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.
        Проблема: Код инициализации больших таких объектов обычно спря- тан внутри монструозного конструктора с десятком 
        параметров. Либо ещё хуже — распылён по всему клиентскому коду.
        Самое простое решение — расширить класс Дом, создав подклассы для всех комбинаций параметров дома. Проблема такого 
        подхода — это громадное количество классов.
        Вы можете создать гигантский конструк- тор Дома , принимающий уйму параметров для контроля над создаваемым продуктом.
        Большая часть этих параметров будет простаивать, а вызовы конструктора будут выглядеть монструозно из-за длинного 
        списка параметров. 
        Решение: Вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, 
        называемым строителями. Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать 
        все шаги, а только те, что нужны для производства объекта определённой конфигурации.
        Например, деревянный дом потребует строительства стен из дерева, а каменный — из камня.
        В этом случае вы можете создать несколько классов строите- лей, выполняющих одни и те же шаги по-разному. 
        Используя этих строителей в одном и том же строительном процессе, вы сможете получать на выходе различные объекты.
        Вы можете пойти дальше и выделить вызовы методов стро- ителя в отдельный класс, называемый директором. В этом случае 
        директор будет задавать порядок шагов строитель- ства, а строитель — выполнять их.
        Преимущества:
        Позволяет создавать продукты пошагово.
        Позволяет использовать один и тот же код для создания раз- личных продуктов.
        Изолирует сложный код сборки продукта от его основной бизнес-логики.
        Недостатки:
        Усложняет код программы из-за введения дополнительных классов.
        Клиент будет привязан к конкретным классам строителей, так как в интерфейсе директора может не быть метода полу- чения 
        результата.

        `,
    }, 
    {
        id: 53,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'HTTP кеширование',
        answer: `
        Производительность веб-сайтов и приложений можно значительно повысить за счёт повторного использования ранее полученных 
        ресурсов. Веб-кеши сокращают задержку и снижают сетевой трафик, уменьшая тем самым время, необходимое для отображения 
        ресурсов. Используя HTTP-кеширование, сайты становятся более отзывчивыми.

        `,
    }, 
    {
        id: 54,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Различные виды кеширования',
        answer: `
        Техника кеширования заключается в сохранении копии полученного ресурса для возврата этой копии в ответ на дальнейшие 
        запросы. Запрос на ресурс, уже имеющийся в веб-кеше, перехватывается, и вместо обращения к исходному серверу выполняется 
        загрузка копии из кеша. Таким образом снижается нагрузка на сервер, которому не приходится самому обслуживать всех клиентов, 
        и повышается производительность — кеш ближе к клиенту и ресурс передаётся быстрее. Кеширование является основным источником
        повышения производительности веб-сайтов. Однако, кеш надо правильно сконфигурировать: ресурсы редко остаются неизменными,
        так что копию требуется хранить только до того момента, как ресурс изменился, но не дольше.
        две основные категории: приватные кеши и кеши совместного использования. В кешах совместного использования (shared cache)
        хранятся копии, которые могут направляться разным пользователям. Приватный кеш (private cache) предназначен для отдельного
        пользователя.
        Cуществуют также кеши шлюзов, CDN, реверсные прокси кеши и балансировщики нагрузки, разворачиваемые на серверах для повышения 
        надёжности, производительности и масштабируемости веб-сайтов и веб-приложений.
        `,
    }, 
    {
        id: 55,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Приватный (private) кеш браузера',
        answer: `
        Приватный кеш предназначен для отдельного пользователя. Вы, возможно, уже видели параметры кеширования в настройках своего 
        браузера. Кеш браузера содержит все документы, загруженные пользователем по HTTP. Он используется для доступа к ранее загруженным 
        страницам при навигации назад/вперёд, позволяет сохранять страницы, или просматривать их код, не обращаясь лишний раз к серверу. 
        Кроме того, кеш полезен при отключении от сети.
        `,
    }, 
    {
        id: 56,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Общий (shared) прокси-кеш',
        answer: `
        Кеш совместного использования — это кеш, который сохраняет ответы, чтобы их потом могли использовать разные пользователи. 
        Например, в локальной сети вашего провайдера или компании, может быть установлен прокси, обслуживающий множество пользователей, 
        чтобы можно было повторно использовать популярные ресурсы, сокращая тем самым сетевой трафик и время ожидания.
        `,
    }, 
    {
        id: 57,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'что обычно записывается в кеш',
        answer: `
        стандартные кеши HTTP обычно способны кешировать только ответы на запросы методом GET, а другие отклоняют.
        Первичный ключ состоит из метода запроса и запрашиваемого URI (зачастую используется только URI, поскольку целью кеширования 
        являются только GET-запросы). Вот примеры того, что обычно записывается в кеш:
        1) Успешно загруженные ресурсы: ответ 200 OK на запрос методом GET HTML-документов, изображений или файлов.
        2) Постоянные перенаправления: ответ 301 Moved Permanently («перемещено навсегда»).
        3) Сообщения об ошибках: ответ 404 Not Found («не найдено»).
        4) Неполные результаты: ответ 206 Partial Content («частичное содержимое»).
        5) Ответы на запросы отличные от GET, если есть что-либо, подходящее для использования в качестве ключа кеша.

        Запись в кеше может также состоять из множества ответов, различаемых по вторичному ключу, если при формировании ответа 
        производится согласование данных.
        `,
    }, 
    {
        id: 58,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Управление кешированием',
        answer: `
        Поле Cache-Control общего заголовка HTTP/1.1 используется для задания инструкций по механизму кеширования как в запросах, 
        так и в ответах. Применяется для задания политик кеширования.
        1) Полное отсутствие кеширования
        В кеше не должно сохраняться ничего — ни по запросам клиента, ни по ответам сервера. Запрос всегда отправляется на сервер, 
        ответ всегда загружается полностью.

        Cache-Control: no-store
        Cache-Control: no-cache, no-store, must-revalidate
        2) Кешировать, но проверять актуальность
        Перед тем, как выдать копию, кеш запрашивает исходный сервер на предмет актуальности ресурса.
        
        Cache-Control: no-cache
        3) Директива "public" указывает, что ответ можно сохранять в любом кеше. Это бывает полезно, если возникает потребность 
        сохранить страницы с HTTP-аутентификацией, или такими кодами ответа, которые обычно не кешируются. Директива же "private" 
        указывает, что ответ предназначен отдельному пользователю и не должен храниться в кеше совместного использования. В этом 
        случае ответ может сохраняться приватным кешем браузера.

        Cache-Control: private
        Cache-Control: public
        4) Срок действия (Expiration)
        Самой важной здесь является директива "max-age=<seconds>" — максимальное время, в течение которого ресурс считается "свежим". 
        В отличие от директивы Expires, она привязана к моменту запроса. К неизменяющимся файлам приложения обычно можно применять 
        "агрессивное" кеширование. Примером таких статических файлов могут быть изображения, файлы стилей (CSS) или скриптов (JavaScript).
    
        Cache-Control: max-age=31536000
        5) Проверка актуальности
        При использовании директивы "must-revalidate" кеш обязан проверять статус ресурсов с истёкшим сроком действия. Те копии, ч
        то утратили актуальность, использоваться не должны. Подробнее об этом рассказано ниже, в разделе Валидация кеша.
        
        Cache-Control: must-revalidate
        6) Заголовок Pragma
        Pragma является заголовком HTTP/1.0. Он не описан для HTTP-ответов и, таким образом, не может служить надёжной заменой
         общему заголовку Cache-Control протокола HTTP/1.1, хотя его поведение аналогично "Cache-Control: no-cache" когда поле 
         заголовка Cache-Control опущено в запросе. Использовать его следует только для совместимости с клиентами HTTP/1.0.
        `,
    }, 
    {
        id: 59,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: '3аголовок HTTP-ответа Vary',
        answer: `
        Заголовок HTTP-ответа Vary определяет, как по заголовкам будущих запросов понять, может ли быть использована копия из кеша, 
        или нужно запросить новые данные у сервера.

        Если кеш получает запрос, который можно удовлетворить сохранённым в кеше ответом с заголовком Vary, то использовать этот 
        ответ можно только при совпадении всех указанных в Vary полей заголовка исходного (сохранённого в кеше) запроса и нового запроса.
        Это может быть полезно, например, при динамическом предоставлении контента. При использовании заголовка Vary: User-Agent 
        кеширующие сервера, принимая решение об использовании страницы из кеша, должны учитывать агент пользователя. Так можно избежать 
        ситуации, когда пользователи мобильных устройств по ошибке получат десктопную версию вашего сайта. Вдобавок, это может помочь
        Google и другим поисковым системам обнаружить мобильную версию страницы, и может также указать им на то, что здесь нет никакой 
        подмены контента с целью поисковой оптимизации (Cloaking).

        Vary: User-Agent
        Поскольку значение заголовка User-Agent различается ("varies") у мобильных и десктопных клиентов, закешированный мобильный 
        контент не будет по ошибке отсылаться пользователям десктопов и наоборот.
        `,
    }, 
    {
        id: 60,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Валидация кеша',
        answer: `
        Валидация кеша запускается при нажатии пользователем кнопки перезагрузки. Кроме того, она может выполняться в ходе обычного 
        просмотра страниц, если кешированный ответ включает заголовок "Cache-control: must-revalidate". Другим фактором являются 
        настройки кеширования браузера — можно потребовать принудительной валидации при каждой загрузке документа.

        При истечении срока годности документа он либо проходит валидацию, либо повторно доставляется с сервера. Валидация может 
        выполняться только если на сервере реализован сильный валидатор или слабый валидатор.
        `,
    }, 
    {
        id: 61,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Заголовки ETag',
        answer: `
        Заголовок ответа ETag является непрозрачным для клиентского приложения (агента) значением, которое можно использовать в 
        качестве сильного валидатора. Суть в том, что клиент, например, браузер, не знает, что представляет эта строка и не может 
        предсказать, каким будет её значение. Если в ответе присутствует заголовок ETag, клиент может транслировать его значение
        через заголовок If-None-Match (en-US) будущих запросов для валидации кешированного ресурса.

        Заголовок ответа Last-Modified можно использовать в качестве слабого валидатора. Слабым он считается из-за того, что имеет 
        1-секундное разрешение. Если в ответе присутствует заголовок Last-Modified, то для валидации кешированного документа клиент 
        может выводить в запросах заголовок If-Modified-Since.

        При запросе на валидацию сервер может либо проигнорировать валидацию и послать стандартный ответ 200 OK, либо вернуть ответ 
        304 Not Modified (с пустым телом), тем самым указывая браузеру взять копию из кеша. В последнем случае в ответ могут входить
        также заголовки для обновления срока действия кешированного ресурса.
        `,
    }, 
    {
        id: 62,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Гипертекст, гиперссылка?',
        answer: `
        Гипертекст - это текст, содержащий ссылки на другие тексты.
        Гиперссылки  позволяют нам связывать наши документы с любым другим документом (или ресурсом), с которым мы хотим. 
        С их помощью мы также можем связывать документы с их конкретными частями, и мы можем сделать приложения доступными на простом 
        веб-адресе (сравните это с локальными приложениями, которые должны быть установлены, и другими такими же вещами). 
        когда вы кликаете по ней (или иным образом активируете), 
        она заставляет веб-браузер перейти на другой веб-адрес (URL.)
        `,
    }, 
    {
        id: 63,
        filter: 'list--filter__patterns',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Паттерны. Поведенческий НАБЛЮДАТЕЛЬ?',
        answer: `
        создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.
        Представьте, что вы имеете два объекта: Покупатель и Магазин . В магазин вот-вот должны завезти новый товар,
        который интересен покупателю.
        Покупатель может каждый день ходить в магазин, чтобы проверить наличие товара. Но при этом он будет злиться, без толку 
        тратя своё драгоценное время.

        С другой стороны, магазин может разослать спам каждому своему покупателю. Многих это расстроит, так как товар спе- цифический,
        и не всем он нужен.
        Получается конфликт: либо покупатель тратит время на периодические проверки, либо магазин тратит ресурсы на бесполезные
        оповещения.
        Давайте называть Издателями те объекты, которые содержат важное или интересное для других состояние. Остальные объекты, 
        которые хотят отслеживать изменения этого состо- яния, назовём Подписчиками.
        Паттерн Наблюдатель предлагает хранить внутри объекта издателя список ссылок на объекты подписчиков, причём издатель не 
        должен вести список подписки самостоятель- но. Он предоставит методы, с помощью которых подписчики могли бы добавлять 
        или убирать себя из списка.
        Когда в издателе будет происхо- дить важное событие, он будет проходиться по списку под- писчиков и оповещать их об этом,
        вызывая определённый метод объектов-подписчиков.
        Издателю безразлично, какой класс будет иметь тот или иной подписчик, так как все они должны следовать общему интерфейсу
        и иметь единый метод оповещения.
        
        `,
    }, 
    {
        id: 64,
        filter: 'list--filter__patterns',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Паттерны. Структурный Адаптер?',
        answer: `
        позволяет объектам с несовместимыми интерфейсами работать вместе.
        Представьте, что вы делаете приложение для торговли на бирже. Ваше приложение скачивает биржевые котировки из нескольких 
        источников в XML, а затем рисует красивые графики.
        В какой-то момент вы решаете улучшить приложение, при- менив стороннюю библиотеку аналитики. Но вот беда — библиотека 
        поддерживает только формат данных JSON, несовместимый с вашим приложением.
        Подключить стороннюю библиотеку не выйдет из-за несовместимых форматов данных.
        Вы можете создать адаптер. Это объект-переводчик, кото- рый трансформирует интерфейс или данные одного объекта в такой вид, 
        чтобы он стал понятен другому объекту.
        При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого. Например, вы можете 
        обернуть объект, работающий в метрах, адапте- ром, который бы конвертировал данные в футы.
        Адаптеры могут не только переводить данные из одного формата в другой, но и помогать объектам с разными интер- фейсами 
        работать сообща. Это работает так:
        1. Адаптер имеет интерфейс, который совместим с одним из объектов.
        2. Поэтому этот объект может свободно вызывать методы адаптера.
        3. Адаптер получает эти вызовы и перенаправляет их второму объекту, но уже в том формате и последовательности, кото- рые 
        понятны второму объекту.
        `,
    }, 
    {
        id: 65,
        filter: 'list--filter__typeScript',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Null в TypeScript. Для чего нужен тип void?',
        answer: `
        Null в ТС имеет тип null, а не object как JS. Тип void обозначает отстутствие типов, когла функция ничего не возвращает.
        результат, который возвращает функция, указываем после круглых скобок (): void {}
        `,
    }, 
    {
        id: 66,
        filter: 'list--filter__typeScript',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Array, generic, tuple, any, enum, never, object, union, Alias?',
        answer: `
        Два способа записать тип Array type
        1) let list: number[] = [1,2,3] Здесь мы говорим, что тип данных числа, и эти числа будут находиться в массиве.
        2) let list: Array<number> = [1,2,3] Generic type. С помощью ключевого слова Array мы задаем тип данных, а затем с 
        помощью number описываем эти данные.
        Tuple - кортеж. В том случае, если массив содержит различные типы данных. [string, number, boolean]
        Тип any можем использовать, если мы не уверены, какой тип данных будем получать, или длинный массив со значениями 
        разных типов.
        Enum перечисление. Смесь массива и объекта. Под капотом анонимная самовызывающаяся функция, которая создает объект.
        Перечисление - удобный способ для задания понятных имен набору численных значений, структурировать однотипные элементы.
        Позволяет создать набор именованных
        числовых констант. Индекс можно переопределить знаком =, последующие индексы поменяют свои значения, чтобы быть по порядку.
        Never type используется, когда функция возвращает ошибку (throw new Error(message)) и не заканчивает свое выполнение или 
        когда функция в бесконечном цикле while(true) {}.
        Object type предназначен для определения объекта или не примитива.
        Union type синтаксис объединения нескольких типов | "или" переменная может иметь любой из типов
        Ключевое слово type - механизм создания пользовательских типов Alias - псевдоним для повторного использования.
        Опер опционал арг-та?,...rest type, Returned type - результат, который возвращ функции.
        Функциональный тип - если в переменную присвоить другую функцию.

        `,
    }, 
    {
        id: 67,
        filter: 'list--filter__typeScript',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Опер опционал арг-та?,...rest type?',
        answer: `
        Два способа записать тип Array type
        1) let list: number[] = [1,2,3] Здесь мы говорим, что тип данных числа, и эти числа будут находиться в массиве.
        2) let list: Array<number> = [1,2,3] Generic type. С помощью ключевого слова Array мы задаем тип данных, а затем с 
        помощью number описываем эти данные.
        Tuple - кортеж. В том случае, если массив содержит различные типы данных. [string, number, boolean]
        Тип any можем использовать, если мы не уверены, какой тип данных будем получать, или длинный массив со значениями 
        разных типов.
        Enum перечисление. Смесь массива и объекта. Под капотом анонимная самовызывающаяся функция, которая создает объект.
        Перечисление - удобный способ для задания понятных имен набору численных значений, структурировать однотипные элементы.
        Позволяет создать набор именованных
        числовых констант. Индекс можно переопределить знаком =, последующие индексы поменяют свои значения, чтобы быть по порядку.
        Never type используется, когда функция возвращает ошибку (throw new Error(message)) и не заканчивает свое выполнение или 
        когда функция в бесконечном цикле while(true) {}.
        Object type предназначен для определения объекта или не примитива.
        Union type синтаксис объединения нескольких типов | "или" переменная может иметь любой из типов
        Ключевое слово type - механизм создания пользовательских типов Alias - псевдоним для повторного использования.
    
        `,
    }, 
    {
        id: 68,
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Классы. Модификаторы доступа?',
        answer: `
        Для определения доступности к свойствам и методам есть 4 ключевых слова:
        1) public - по умолчанию
        2) private - только для этого класса (нет доступа извне и из наследуемых классов)
        3) protected - нет доступа извне, но наследуемые классы могут использовать
        4) readonly - свойство только для чтения
        5) static - статические свойства класса, которые видны в классе без создания экземпляра (присвоить метод самому классу).
        `,
    }, 
    {
        id: 69,
        filter: 'list--filter__react',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Разница между функц и класс компонентами',
        answer: `
        Есть субъективное мнение, что порог вхождения в класовые компоненты сложнее.
        Объективная разница:
        Хуки проще, чем методы жизненного цикла, их проще выносить и создавать кастомные хуки, переиспользовать логику.
        Мы можем создать любое количество useEffect'ов, хуков.
        Минусы - react.memo работает только с props (без state).
        Сама функция является рендером и поэтому вынуждена использовать useMemo и useCallback для оптимизации, потому что выполнится
        все тело функции, в том числе и return. 

        Классовый компонент тяжелее по двум причинам:
        1) Вынужден хранить в себе методы жизненного цикла, даже если он их не использует,=> наследуется от Реакт.компонент
        2) Перед тем, как компонент создастся, он обязан создать экземпляр инстанс, сам по себе класс не работает. 
        Он должен создать объект, чтобы получить свой узел. Это дополнительная работа для Файбера. 
        Файбер может определить какой перед ним компонент классовый или функц. (по типу).
        По утверждению разработчиков, файбер работает быстрее с функц компонентами. 
        Чтобы вынести логику из классового компонента нам приходится создавать дополнительные обертки контейнеры -> компоненты
        высшего порядка.
        И не сморя на то, что в конечном итоге в ДОМ отрисуется какой-то рендер, в реакт дереве это будет не один узел, а
        несколько узлов, целое дерево вложенных узлов. Каждая обертка - это новый узел.
        Реакту проще пересивать один кампонент, чем работать с деревом.
        В классовых компонентов вынуждены использовать несколько методов жизненного цикла и приходится писать большое количество
        кода в одном месте, что затрудняет отладку кода.
        Плюсы классов, что нам доступен PureComponent, который нам позволяет работать и со state и с props.
        Еще у класса есть render. Когда класс обновляется, рендер запускается в конце и поля класса не отрабатывают заново.
        Нет проблемы с мемоизацией. ПОэтому, если класс простой, то может он будет и быстрее.
        `,
    },
    {
        id: 70,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 1,      
        title: 'Cookie?',
        answer: `
        HTTP cookie (web cookie, куки браузера) - это небольшой фрагмент данных, который сервер отправляет браузеру пользователя. 
        Браузер может сохранить этот фрагмент у себя и отправлять на сервер с каждым последующим запросом. Это, в частности, 
        позволяет узнать, с одного ли браузера пришли несколько запросов (например, для аутентификации пользователя). С помощью
        кук можно сохранить любую информацию о состоянии, HTTP-протокол сам по себе этого делать не умеет.
        Куки часто используются для:

        1) Управления сеансом (логины, корзины для виртуальных покупок)
        2) Персонализации (пользовательские предпочтения)
        3) Трекинга (отслеживания поведения пользователей)
        `,
    }, 
    {
        id: 71,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Создание Cookie?',
        answer: `
        Получив HTTP-запрос, вместе с ответом сервер может отправить заголовок Set-Cookie. Куки обычно запоминаются браузером и 
        посылаются в HTTP-заголовке Cookie (en-US) с каждым новым запросом к одному и тому же серверу. Можно задать срок действия 
        кук, а также срок их жизни, после которого куки не будут отправляться. Также можно указать ограничения на путь и домен, 
        то есть указать, в течении какого времени и к какому сайту они будут отсылаться.
        Заголовок Set-Cookie с сервера даёт клиенту указание сохранить куки. Ответ, отправляемый браузеру, содержит заголовок 
        Set-Cookie, и куки запоминается браузером.

        Set-Cookie: yummy_cookie=choco
        Set-Cookie: tasty_cookie=strawberry
        Теперь с каждым новым запросом к серверу при помощи заголовка Cookie (en-US) браузер будет возвращать серверу все сохранённые ранее куки.

        GET /sample_page.html HTTP/1.1
        Host: www.example.org
        Cookie: yummy_cookie=choco; tasty_cookie=strawberry
        `,
    }, 
    {
        id: 72,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'TCP и UDP?',
        answer: `
        Transmission Control Protocol
        Unreliable Datagram Protocol (англ. — Ненадёжный протокол датаграмм) UDP обеспечивает многоканальную передачу (с помощью номеров портов)
        Оба протокола отвечают за передачу данных и работают поверх IP, но с небольшой разницей. TCP доставляет данные без потерь, поэтому его 
        используют для передачи фотографий, сообщений и другой важной информации. А вот UDP не гарантирует доставку, но зато он гораздо быстрее. 
        Его используют, когда скорость важнее надёжности, например, при передаче аудиосообщений или видеотрансляциях.
        `,
    }, 
    {
        id: 73,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'XMLHttpRequest?',
        answer: `
        XMLHttpRequest это API, который предоставляет клиенту функциональность для обмена данными между клиентом и сервером. Данный API предоставляет 
        простой способ получения данных по ссылке без перезагрузки страницы. Это позволяет обновлять только часть веб-страницы не прерывая пользователя.
        XMLHttpRequest используется в AJAX запросах и особенно в single-page приложениях.
        `,
    }, 
    {
        id: 74,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 2,      
        title: 'CORS?',
        answer: `
        Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя 
        получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент.
         Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается 
         от запрашиваемого ресурса доменом, протоколом или портом.
        Стандарт Cross-Origin Resource Sharing работает с помощью добавления новых HTTP-заголовков, которые позволяют серверам описывать набор 
        источников, которым разрешено читать информацию, запрашиваемую web-браузером. В частности, для методов HTTP-запросов, которые могут привести 
        к побочным эффектам над данными сервера (в частности, для HTTP методов, отличных от GET или для POST запросов, использующих определённые
        MIME-типы), спецификация требует, чтобы браузеры "предпроверяли" запрос, запрашивая поддерживающие методы с сервера с помощью метода 
        HTTP-запроса OPTIONS и затем, поверх "подтверждения" с сервера, отсылали фактический запрос с фактическим методом HTTP-запроса. 
        Сервера также могут оповещать клиентов должны ли "полномочия" (включая Cookies и HTTP Authentication данные) быть отправлены с запросом. 
        `,
    }, 
    {
        id: 75,
        filter: 'list--filter__network',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'LocalStorage, sessionStorage',
        answer: `
        Объекты веб-хранилища localStorage и sessionStorage позволяют хранить пары ключ/значение в браузере.
        Что в них важно – данные, которые в них записаны, сохраняются после обновления страницы (в случае sessionStorage) и даже после перезапуска
        браузера (при использовании localStorage). 
        В отличие от куки, объекты веб-хранилища не отправляются на сервер при каждом запросе. Именно поэтому мы можем хранить гораздо больше
        данных. Большинство современных браузеров могут выделить как минимум 5 мегабайтов данных (или больше), и этот размер можно поменять в настройках.
        Ещё одно отличие от куки – сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё делается при помощи JavaScript.
        Хранилище привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища, 
        и они не могут получить доступ к данным друг друга.
        Как видим, интерфейс похож на Map (setItem/getItem/removeItem), но также позволяет получить доступ к элементу по индексу – key(index).
        1) key и value должны быть строками.
        2) Лимит 5 Мб+, зависит от браузера.
        3) Данные не имеют «времени истечения».
        4) Данные привязаны к источнику (домен/протокол/порт).

        localStorage	
    
        1) Совместно используется между всеми вкладками и окнами с одинаковым источником	
        2) «Переживает» перезапуск браузера

        sessionStorage
        1) Разделяется в рамках вкладки браузера, среди ифреймов 
        из того же источника 
        2) «Переживает» перезагрузку страницы (но не закрытие вкладки)
        `,
    }, 
    {
        // id: 76,
        filter: 'common',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Babel, для чего используется?',
        answer: `
            Babel- это транспайлер, который переписывает код современного JS на более поздний. 
        `,
    }, 
    {
        // id: 77,
        filter: 'tasks Typescript',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Задачи. Typescript',
        answer: `

        1) Тайпскрипт ругается на обращение к свойству объекта через строку массива. В чем причина, как починить?
        const obj = {
            key: 1
        };

        const arr = ['key'];
        
        arr. forEach( arrkey => {
            obj[arrkey]
        })

        Ответ: в обхекте указано конкретное имя свойства key,  а обращаемся к свойству по массиву строк.
        Решение: const arr: Array<'key'> = ['key'];
        `,
    }, 
    {
        // id: 78,
        filter: 'JS',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Разница var let const. Function declar, func expression?',
        answer: `
        Function declar можно вызвать до ее декларации, поскольку функция всплывает и записывается в память. 
        фукц выражение вызвать раньше декларации нельзя.
        Главное отличие var то let const- это область видимость функциональная против блочной.
        `,
    }, 
    {
        // id: 79,
        filter: 'JS',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: '=> функции и this. SetTimeout и this?',
        answer: `
            1) Стрелочные функции не блокируют ОБЛАСТЬ ВИДИМОСТИ оператора this. То есть значение this выходит 
            из области видимости самой функции.

            2) setTimeout(function() {
                console.log(this.mountainsr.join(", "));
            }, 100);

            смысл в том, что мы не знаем как под капотом движок запускает функцию, по какой форме вызова. 
            А если будет стрелочная функция, то она берез this снаружи.
            Еще  =>  нет возможности привязать контекст, потому что у нее нет своего this.
        `,
    }, 
    {
        // id: 80,
        filter: 'JS',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Деструкторизация объектов ES6',
        answer: `
        Деструктурирующее присваивание позволяет локально определять область ви- димости полей внутри
         объекта и объявлять, какие значения будут использовать- ся. 
         Рассмотрим объект sandwich. У него четыре ключа, но мы хотим использовать значения только двух из
          них. Допустим, bread и meat будут доступны локально:
        const sandwich = {
        bread: "dutch crunch",
        meat: "tuna",
        cheese: "swiss",
        toppings: ["lettuce", "tomato", "mustard"]
        };
        const { bread, meat } = sandwich;
        console.log(bread, meat); // dutch crunch tuna
        Код извлекает из объекта bread и meat и создает для них локальные переменные. Кроме того, поскольку мы 
        объявили эти переменные с помощью let, их можно изменить без изменения исходного сэндвича.

        И еще Вместо того чтобы использовать синтаксис точечной нотации для изучения объектов, мы деструктурируем 
        нужные значения из объекта regularPerson:
        const lordify = ({ firstname }) => {
        console.log(``}$firstname} of Canterbury``);
        };

        Продвинемся на один уровень дальше и проследим за изменениями данных. Теперь у объекта regularPerson есть 
        новый вложенный объект на ключе spouse:
        const regularPerson = {
        firstname: "Bill",
        lastname: "Wilson",
        spouse: {
        firstname: "Phil",
          lastname: "Wilson"
        }
        };

        Чтобы присвоить звание лорда ему тоже, нужно слегка скорректировать де- структурированные аргументы функции:
        const lordify = ({ spouse: { firstname } }) => {
         console.log(``$firstname} of Canterbury``);
        };
        `,
    }, 
    {
        // id: 81,
        filter: 'JS',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Деструкторизация Array ES6',
        answer: `
        Также можно деструктурировать значения из массивов. Представьте, что вы хотите присвоить первое значение массива
         имени переменной:
        const [firstAnimal] = ["Horse", "Mouse", "Cat"];
        console.log(firstAnimal); // Horse
        Можно передать ненужные значения через сопоставление со списком с помощью запятых, обозначающих элементы, которые 
        следует пропускать. Имея тот же массив, мы можем получить доступ к последнему значению, заменив первые два значения запятыми:
        const [, , thirdAnimal] = ["Horse", "Mouse", "Cat"];
        console.log(thirdAnimal); // Cat
        `,
    }, 
    {
        // id: 82,
        filter: 'JS',
        repeatedTimeStamp: 1673354018170,  
        timesBeenRepeated: 0,      
        title: 'Расширение объектного литерала ES6',
        answer: `
        Расширение объектного литерала противоположно деструктуризации. Это процесс реструктуризации или воссоздания объекта. Он 
        позволяет брать пере- менные из глобальной области видимости и добавлять их к объекту:
        С помощью расширения объектного литерала или реструктуризации также
        можно создавать методы объекта:
        Обратите внимание, что мы используем оператор this для доступа к ключам объекта.
        При определении методов объекта больше не нужно использовать ключевое слово function:
        const name = "Tallac";
        const elevation = 9738;
        const print = function() {
        console.log(``Mt. $]{this.name} is $]{this.elevation} feet tall``);
        };
        const funHike = { name, elevation, print };
        funHike.print(); // Mt. Tallac is 9738 feet tall
        Расширение объектного литерала позволяет включать глобальные переменные в объекты и сокращает количество текста, делая ключевое
         слово function не- нужным.
        `,
    }, 
];

module.exports = dataBase;